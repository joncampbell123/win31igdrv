;	Static Name Aliases
;
	TITLE   midiin.c
	.286p
	.287
INCLUDELIB      MLIBCE
INCLUDELIB	OLDNAMES.LIB
MIDI	SEGMENT  WORD PUBLIC 'CODE'
MIDI	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT  BYTE PUBLIC 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT  BYTE PUBLIC 'DEBTYP'
$$TYPES	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP
	ASSUME  SS: NOTHING
EXTRN	LOADSTRING:FAR
EXTRN	MIDSTART:FAR
EXTRN	MIDSTOP:FAR
EXTRN	CRITENTER:FAR
EXTRN	CRITLEAVE:FAR
EXTRN	MIDACQUIREHARDWARE:FAR
EXTRN	MIDRELEASEHARDWARE:FAR
EXTRN	OUTPUTDEBUGSTR:FAR
EXTRN	INITDISPLAYCONFIGERRORS:FAR
EXTRN	MIDICALLBACK:FAR
EXTRN	MEMCOPY:FAR
EXTRN	TIMEGETTIME:FAR
EXTRN	_STR_CRLF:BYTE
EXTRN	_ghModule:WORD
EXTRN	_gMidiInClient:BYTE
EXTRN	_gfEnabled:BYTE
EXTRN	_wDebugLevel:WORD
EXTRN	_gMIMC:BYTE
_DATA      SEGMENT
$SG2656	DB	'MIDM_INIT',  00H
$SG2658	DB	'midMessage called while disabled',  00H
$SG2661	DB	'invalid midi device id',  00H
$SG2668	DB	'MIDM_GETNUMDEVS',  00H
$SG2671	DB	'MIDM_GETDEVCAPS',  00H
$SG2674	DB	'MIDM_OPEN',  00H
$SG2677	DB	'MIDI input hardware is unavailable!',  00H
$SG2680	DB	'MIDM_CLOSE',  00H
$SG2684	DB	'MIDI input hardware could NOT be released!',  00H
$SG2687	DB	'MIDM_ADDBUFFER',  00H
$SG2690	DB	'MIDM_START',  00H
$SG2693	DB	'MIDM_STOP',  00H
$SG2696	DB	'MIDM_RESET',  00H
$SG2700	DB	'AssertF failed (0)',  00H
_DATA      ENDS
MIDI      SEGMENT
	ASSUME	CS: MIDI
	PUBLIC	MIDFREEQ
MIDFREEQ	PROC NEAR
;|*** /****************************************************************************
;|***  *
;|***  *   midiin.c
;|***  *
;|***  *   Copyright (c) 1991-1992 Microsoft Corporation.  All Rights Reserved.
;|***  *
;|***  ***************************************************************************/
;|*** 
;|*** #include <windows.h>
;|*** #include <mmsystem.h>
;|*** #include <mmddk.h>
;|*** #include "sndblst.h"
;|*** 
;|*** extern MIDIINMSGCLIENT  gMIMC;          /* MIDI input msg client */
;|*** 
;|*** /*****************************************************************************
;|*** 
;|***     internal function prototypes
;|*** 
;|***  ****************************************************************************/ 
;|*** 
;|*** static void NEAR PASCAL midFreeQ(void);
;|*** static void NEAR PASCAL midGetDevCaps(LPBYTE lpCaps, WORD wSize);
;|*** 
;|*** /****************************************************************************
;|***  * @doc INTERNAL
;|***  *
;|***  * @api void | midFreeQ | Free all buffers in the MIQueue.
;|***  *
;|***  * @comm Currently this is only called after sending off any partially filled
;|***  *     buffers, so all buffers here are empty.  The timestamp value is 0 in
;|***  *     this case.
;|***  *
;|***  * @rdesc There is no return value.
;|***  ***************************************************************************/ 
;|*** static void NEAR PASCAL midFreeQ(void)
;|*** {
; Line 37
	*** 000000	c8 0c 00 00 		enter	12,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	lpH = -12
;	lpN = -8
;	dwTime = -4
;|*** LPMIDIHDR   lpH, lpN;
;|*** DWORD       dwTime;
;|*** 
;|***     lpH = gMIMC.lpmhQueue;              /* point to top of the queue */
; Line 41
	*** 000006	a1 14 00 		mov	ax,WORD PTR _gMIMC+20
	*** 000009	8b 16 16 00 		mov	dx,WORD PTR _gMIMC+22
	*** 00000d	8b f0 			mov	si,ax
	*** 00000f	89 56 f6 		mov	WORD PTR [bp-10],dx
;|***     gMIMC.lpmhQueue = NULL;             /* mark the queue as empty */
; Line 42
	*** 000012	2b c0 			sub	ax,ax
	*** 000014	a3 16 00 		mov	WORD PTR _gMIMC+22,ax
	*** 000017	a3 14 00 		mov	WORD PTR _gMIMC+20,ax
;|***     gMIMC.dwCurData = 0L;
; Line 43
	*** 00001a	a3 12 00 		mov	WORD PTR _gMIMC+18,ax
	*** 00001d	a3 10 00 		mov	WORD PTR _gMIMC+16,ax
;|*** 
;|***     dwTime = timeGetTime() - gMIMC.dwRefTime;
; Line 45
	*** 000020	9a 00 00 00 00 		call	FAR PTR TIMEGETTIME
	*** 000025	2b 06 0c 00 		sub	ax,WORD PTR _gMIMC+12
	*** 000029	1b 16 0e 00 		sbb	dx,WORD PTR _gMIMC+14
	*** 00002d	89 46 fc 		mov	WORD PTR [bp-4],ax	;dwTime
	*** 000030	89 56 fe 		mov	WORD PTR [bp-2],dx
;|*** 
;|***     while (lpH) {
; Line 47
	*** 000033	8b 46 f6 		mov	ax,WORD PTR [bp-10]
	*** 000036	0b c6 			or	ax,si
	*** 000038	74 43 			je	$EX2614
					$FC2619:
;|***         lpN = lpH->lpNext;
; Line 48
	*** 00003a	8e 46 f6 		mov	es,WORD PTR [bp-10]
	*** 00003d	26 8b 44 14 		mov	ax,WORD PTR es:[si+20]
	*** 000041	26 8b 54 16 		mov	dx,WORD PTR es:[si+22]
	*** 000045	8b f8 			mov	di,ax
	*** 000047	89 56 fa 		mov	WORD PTR [bp-6],dx
;|***         lpH->dwFlags |= MHDR_DONE;
; Line 49
	*** 00004a	26 80 4c 10 01 		or	BYTE PTR es:[si+16],1
;|***         lpH->dwFlags &= ~MHDR_INQUEUE;
; Line 50
	*** 00004f	26 80 64 10 fb 		and	BYTE PTR es:[si+16],251	;00fbH
;|***         lpH->dwBytesRecorded = 0;
; Line 51
	*** 000054	2b c0 			sub	ax,ax
	*** 000056	26 89 44 0a 		mov	WORD PTR es:[si+10],ax
	*** 00005a	26 89 44 08 		mov	WORD PTR es:[si+8],ax
;|***         midiCallback(&gMidiInClient, MIM_LONGDATA, (DWORD)lpH, dwTime);
; Line 52
	*** 00005e	68 00 00 		push	OFFSET _gMidiInClient
	*** 000061	68 c4 03 		push	964	;03c4H
	*** 000064	06 			push	es
	*** 000065	56 			push	si
	*** 000066	ff 76 fe 		push	WORD PTR [bp-2]
	*** 000069	ff 76 fc 		push	WORD PTR [bp-4]	;dwTime
	*** 00006c	9a 00 00 00 00 		call	FAR PTR MIDICALLBACK
;|***         lpH = lpN;
;|***     }
; Line 54
	*** 000071	8b 46 fa 		mov	ax,WORD PTR [bp-6]
	*** 000074	8b f7 			mov	si,di
	*** 000076	89 46 f6 		mov	WORD PTR [bp-10],ax
	*** 000079	0b c7 			or	ax,di
	*** 00007b	75 bd 			jne	$FC2619
;|*** }
; Line 55
					$EX2614:
	*** 00007d	5e 			pop	si
	*** 00007e	5f 			pop	di
	*** 00007f	c9 			leave	
	*** 000080	c3 			ret	
	*** 000081	90 			nop	

MIDFREEQ	ENDP
	PUBLIC	MIDADDBUFFER
MIDADDBUFFER	PROC NEAR
;|*** 
;|*** /****************************************************************************
;|***  * @doc INTERNAL
;|***  *
;|***  * @api void | midAddBuffer | This function adds a buffer to the list of
;|***  *      wave input buffers.
;|***  *
;|***  * @parm LPWAVEHDR | lpWIHdr | Far pointer to a wave input data header.
;|***  *
;|***  * @rdesc The return value is an MMSYS error code (0L if success).
;|***  *
;|***  * @comm We assume that the header and block are both page locked when they
;|***  *      get here.  That is, it has been 'prepared.'
;|***  ***************************************************************************/ 
;|*** static DWORD NEAR PASCAL midAddBuffer( LPMIDIHDR lpmh )
;|*** {
; Line 71
	*** 000082	c8 08 00 00 		enter	8,0
	*** 000086	57 			push	di
	*** 000087	56 			push	si
;	lpN = -4
;	lpmh = 4
	*** 000088	8b 7e 04 		mov	di,WORD PTR [bp+4]	;lpmh
;|*** LPMIDIHDR   lpN;
;|*** 
;|***     /* check if it's been prepared */
;|***     if (!(lpmh->dwFlags & MHDR_PREPARED))
; Line 75
	*** 00008b	8e 46 06 		mov	es,WORD PTR [bp+6]
	*** 00008e	26 f6 45 10 02 		test	BYTE PTR es:[di+16],2
	*** 000093	75 05 			jne	$I2626
;|***         return MIDIERR_UNPREPARED;
; Line 76
	*** 000095	b8 40 00 		mov	ax,64	;0040H
	*** 000098	eb 7c 			jmp	SHORT $L2708
;|*** 
;|***     /* check if it's in our queue already */
;|***     if (lpmh->dwFlags & MHDR_INQUEUE)
; Line 79
					$I2626:
	*** 00009a	26 f6 45 10 04 		test	BYTE PTR es:[di+16],4
	*** 00009f	74 05 			je	$I2627
;|***         return MIDIERR_STILLPLAYING;
; Line 80
	*** 0000a1	b8 41 00 		mov	ax,65	;0041H
	*** 0000a4	eb 70 			jmp	SHORT $L2708
;|*** 
;|***     /* add the buffer to our queue */
;|***     lpmh->dwFlags |= MHDR_INQUEUE;
; Line 83
					$I2627:
	*** 0000a6	26 80 4d 10 04 		or	BYTE PTR es:[di+16],4
;|***     lpmh->dwFlags &= ~MHDR_DONE;
; Line 84
	*** 0000ab	26 80 65 10 fe 		and	BYTE PTR es:[di+16],254	;00feH
;|*** 
;|***     /* sanity */
;|***     lpmh->dwBytesRecorded = 0;
; Line 87
	*** 0000b0	2b c0 			sub	ax,ax
	*** 0000b2	26 89 45 0a 		mov	WORD PTR es:[di+10],ax
	*** 0000b6	26 89 45 08 		mov	WORD PTR es:[di+8],ax
;|***     lpmh->lpNext = NULL;
; Line 88
	*** 0000ba	26 89 45 16 		mov	WORD PTR es:[di+22],ax
	*** 0000be	26 89 45 14 		mov	WORD PTR es:[di+20],ax
;|*** 
;|***     CritEnter();
; Line 90
	*** 0000c2	9a 00 00 00 00 		call	FAR PTR CRITENTER
;|***     {
;|***         if ( lpN = gMIMC.lpmhQueue ) {
; Line 92
	*** 0000c7	a1 14 00 		mov	ax,WORD PTR _gMIMC+20
	*** 0000ca	8b 16 16 00 		mov	dx,WORD PTR _gMIMC+22
	*** 0000ce	8b f0 			mov	si,ax
	*** 0000d0	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 0000d3	0b d0 			or	dx,ax
	*** 0000d5	75 0c 			jne	$L2703
;|***             while ( lpN->lpNext && (lpN = lpN->lpNext) )
;|***                 ;
;|*** 
;|***             lpN->lpNext = lpmh;
;|***         }
;|*** 
;|***         else 
;|***             gMIMC.lpmhQueue = lpmh;
; Line 100
	*** 0000d7	8b 46 06 		mov	ax,WORD PTR [bp+6]
	*** 0000da	89 3e 14 00 		mov	WORD PTR _gMIMC+20,di
	*** 0000de	a3 16 00 		mov	WORD PTR _gMIMC+22,ax
	*** 0000e1	eb 2c 			jmp	SHORT $I2632
					$L2703:
;|***             while ( lpN->lpNext && (lpN = lpN->lpNext) )
; Line 93
	*** 0000e3	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 0000e6	26 8b 44 14 		mov	ax,WORD PTR es:[si+20]
	*** 0000ea	26 8b 54 16 		mov	dx,WORD PTR es:[si+22]
	*** 0000ee	89 56 fa 		mov	WORD PTR [bp-6],dx
	*** 0000f1	0b d0 			or	dx,ax
	*** 0000f3	74 0c 			je	$FB2631
	*** 0000f5	8b 56 fa 		mov	dx,WORD PTR [bp-6]
	*** 0000f8	8b f0 			mov	si,ax
	*** 0000fa	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 0000fd	0b d0 			or	dx,ax
	*** 0000ff	75 e2 			jne	$L2703
;|***                 ;
; Line 94
					$FB2631:
;|*** 
;|***             lpN->lpNext = lpmh;
; Line 96
	*** 000101	8b 46 06 		mov	ax,WORD PTR [bp+6]
	*** 000104	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 000107	26 89 7c 14 		mov	WORD PTR es:[si+20],di
	*** 00010b	26 89 44 16 		mov	WORD PTR es:[si+22],ax
;|***         }
;|*** 
;|***         else 
;|***             gMIMC.lpmhQueue = lpmh;
; Line 100
					$I2632:
;|***     }
;|***     CritLeave();
; Line 102
	*** 00010f	9a 00 00 00 00 		call	FAR PTR CRITLEAVE
;|*** 
;|***     /* return success */
;|***     return ( 0L );
; Line 105
	*** 000114	33 c0 			xor	ax,ax
					$L2708:
	*** 000116	33 d2 			xor	dx,dx
;|*** }
; Line 106
	*** 000118	5e 			pop	si
	*** 000119	5f 			pop	di
	*** 00011a	c9 			leave	
	*** 00011b	c2 04 00 		ret	4
	*** 00011e	90 			nop	
	*** 00011f	90 			nop	

MIDADDBUFFER	ENDP
	PUBLIC	MIDSENDPARTBUFFER
MIDSENDPARTBUFFER	PROC NEAR
;|*** 
;|*** /****************************************************************************
;|***  * @doc INTERNAL
;|***  * 
;|***  * @api WORD | midSendPartBuffer | This function is called from midStop().
;|***  *     It looks at the buffer at the head of the queue and, if it contains
;|***  *     any data, marks it as done as sends it back to the client.
;|***  * 
;|***  * @rdesc The return value is the number of bytes transfered. A value of zero
;|***  *     indicates that there was no more data in the input queue.
;|***  ***************************************************************************/ 
;|*** void NEAR PASCAL midSendPartBuffer(void)
;|*** {
; Line 119
	*** 000120	56 			push	si
;	lpH = -4
;|*** LPMIDIHDR lpH;
;|*** 
;|***     if ( gMIMC.lpmhQueue && gMIMC.dwCurData ) {
; Line 122
	*** 000121	a1 16 00 		mov	ax,WORD PTR _gMIMC+22
	*** 000124	0b 06 14 00 		or	ax,WORD PTR _gMIMC+20
	*** 000128	74 4c 			je	$EX2633
	*** 00012a	a1 12 00 		mov	ax,WORD PTR _gMIMC+18
	*** 00012d	0b 06 10 00 		or	ax,WORD PTR _gMIMC+16
	*** 000131	74 43 			je	$EX2633
;|***         lpH = gMIMC.lpmhQueue;
; Line 123
	*** 000133	a1 14 00 		mov	ax,WORD PTR _gMIMC+20
	*** 000136	8b 16 16 00 		mov	dx,WORD PTR _gMIMC+22
	*** 00013a	8b f0 			mov	si,ax
;|***         gMIMC.lpmhQueue = gMIMC.lpmhQueue->lpNext;
; Line 124
	*** 00013c	8b d8 			mov	bx,ax
	*** 00013e	8e c2 			mov	es,dx
	*** 000140	26 8b 47 14 		mov	ax,WORD PTR es:[bx+20]
	*** 000144	26 8b 57 16 		mov	dx,WORD PTR es:[bx+22]
	*** 000148	a3 14 00 		mov	WORD PTR _gMIMC+20,ax
	*** 00014b	89 16 16 00 		mov	WORD PTR _gMIMC+22,dx
;|***         gMIMC.dwCurData = 0L;
; Line 125
	*** 00014f	2b c0 			sub	ax,ax
	*** 000151	a3 12 00 		mov	WORD PTR _gMIMC+18,ax
	*** 000154	a3 10 00 		mov	WORD PTR _gMIMC+16,ax
;|***         lpH->dwFlags |= MHDR_DONE;
; Line 126
	*** 000157	26 80 4c 10 01 		or	BYTE PTR es:[si+16],1
;|***         lpH->dwFlags &= ~MHDR_INQUEUE;
; Line 127
	*** 00015c	26 80 64 10 fb 		and	BYTE PTR es:[si+16],251	;00fbH
;|***         midiCallback(&gMidiInClient, MIM_LONGERROR, (DWORD)lpH,gMIMC.dwMsgTime);
; Line 128
	*** 000161	68 00 00 		push	OFFSET _gMidiInClient
	*** 000164	68 c6 03 		push	966	;03c6H
	*** 000167	06 			push	es
	*** 000168	56 			push	si
	*** 000169	ff 36 0a 00 		push	WORD PTR _gMIMC+10
	*** 00016d	ff 36 08 00 		push	WORD PTR _gMIMC+8
	*** 000171	9a 00 00 00 00 		call	FAR PTR MIDICALLBACK
;|***     }
;|*** }
; Line 130
					$EX2633:
	*** 000176	5e 			pop	si
	*** 000177	c3 			ret	

MIDSENDPARTBUFFER	ENDP
	PUBLIC	MIDGETDEVCAPS
MIDGETDEVCAPS	PROC NEAR
;|*** 
;|*** /*****************************************************************************
;|***  * @doc INTERNAL
;|***  *
;|***  * @api void | midGetDevCaps | Get the capabilities of the port.
;|***  *
;|***  * @parm LPBYTE | lpCaps | Far pointer to a MIDIINCAPS structure.
;|***  *
;|***  * @parm WORD | wSize | Size of the MIDIINCAPS structure.
;|***  *
;|***  * @rdesc There is no return value.
;|***  ****************************************************************************/
;|*** static void NEAR PASCAL midGetDevCaps(LPBYTE lpCaps, WORD wSize)
;|*** {
; Line 144
	*** 000178	c8 26 00 00 		enter	38,0
;	lpCaps = 6
;	wSize = 4
;	mc = -38
;|*** MIDIINCAPS mc;
;|*** 
;|***     mc.wMid = MM_MICROSOFT;
; Line 147
	*** 00017c	c7 46 da 01 00 		mov	WORD PTR [bp-38],1	;mc
;|***     mc.wPid = MM_SNDBLST_MIDIIN;
; Line 148
	*** 000181	c7 46 dc 04 00 		mov	WORD PTR [bp-36],4
;|***     mc.vDriverVersion = DRIVER_VERSION;
; Line 149
	*** 000186	c7 46 de 01 01 		mov	WORD PTR [bp-34],257	;0101H
;|***     LoadString(ghModule, IDS_SNDBLSTMIDIIN, mc.szPname, MAXPNAMELEN);
; Line 150
	*** 00018b	ff 36 00 00 		push	WORD PTR _ghModule
	*** 00018f	6a 20 			push	32	;0020H
	*** 000191	8d 46 e0 		lea	ax,WORD PTR [bp-32]
	*** 000194	16 			push	ss
	*** 000195	50 			push	ax
	*** 000196	6a 20 			push	32	;0020H
	*** 000198	9a 00 00 00 00 		call	FAR PTR LOADSTRING
;|*** 
;|***     MemCopy(lpCaps, &mc, min(wSize, sizeof(MIDIINCAPS)));
; Line 152
	*** 00019d	ff 76 08 		push	WORD PTR [bp+8]
	*** 0001a0	ff 76 06 		push	WORD PTR [bp+6]	;lpCaps
	*** 0001a3	8d 46 da 		lea	ax,WORD PTR [bp-38]	;mc
	*** 0001a6	16 			push	ss
	*** 0001a7	50 			push	ax
	*** 0001a8	8b 46 04 		mov	ax,WORD PTR [bp+4]	;wSize
	*** 0001ab	3d 26 00 		cmp	ax,38	;0026H
	*** 0001ae	76 03 			jbe	$L2704
	*** 0001b0	b8 26 00 		mov	ax,38	;0026H
					$L2704:
	*** 0001b3	50 			push	ax
	*** 0001b4	9a 00 00 00 00 		call	FAR PTR MEMCOPY
;|*** }
; Line 153
	*** 0001b9	c9 			leave	
	*** 0001ba	c2 06 00 		ret	6
	*** 0001bd	90 			nop	

MIDGETDEVCAPS	ENDP
	PUBLIC	MIDMESSAGE
MIDMESSAGE	PROC FAR
;|*** 
;|*** /****************************************************************************
;|*** 
;|***     This function conforms to the standard MIDI input driver message proc
;|*** 
;|*** ****************************************************************************/
;|*** DWORD FAR PASCAL _loadds midMessage(WORD id, UINT msg, DWORD dwUser, DWORD dwParam1, DWORD dwParam2)
;|*** {
; Line 161
	*** 0001be	55 			push	bp
	*** 0001bf	8b ec 			mov	bp,sp
	*** 0001c1	56 			push	si
	*** 0001c2	1e 			push	ds
	*** 0001c3	b8 00 00 		mov	ax,DGROUP
	*** 0001c6	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
;	id = 20
;	msg = 18
;	dwUser = 14
;	dwParam1 = 10
;	dwParam2 = 6
;|***     if ( !gfEnabled ) {
; Line 162
	*** 0001c8	80 3e 00 00 00 		cmp	BYTE PTR _gfEnabled,0
	*** 0001cd	75 55 			jne	$I2653
	*** 0001cf	8b 76 12 		mov	si,WORD PTR [bp+18]	;msg
;|***         if ( msg == MIDM_INIT ) {
; Line 163
	*** 0001d2	83 fe 64 		cmp	si,100	;0064H
	*** 0001d5	75 23 			jne	$I2654
;|***             D1("MIDM_INIT");
; Line 164
	*** 0001d7	83 3e 00 00 01 		cmp	WORD PTR _wDebugLevel,1
	*** 0001dc	72 14 			jb	$I2655
	*** 0001de	68 00 00 		push	SEG _STR_CRLF
	*** 0001e1	68 00 00 		push	OFFSET _STR_CRLF
	*** 0001e4	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
	*** 0001e9	1e 			push	ds
	*** 0001ea	68 00 00 		push	OFFSET DGROUP:$SG2656
	*** 0001ed	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
;|***             InitDisplayConfigErrors();
; Line 165
					$I2655:
	*** 0001f2	9a 00 00 00 00 		call	FAR PTR INITDISPLAYCONFIGERRORS
	*** 0001f7	e9 8f 02 		jmp	$L2709
;|***             return 0L;
;|***         }
;|*** 
;|***         D1("midMessage called while disabled");
; Line 169
					$I2654:
	*** 0001fa	83 3e 00 00 01 		cmp	WORD PTR _wDebugLevel,1
	*** 0001ff	72 14 			jb	$I2657
	*** 000201	68 00 00 		push	SEG _STR_CRLF
	*** 000204	68 00 00 		push	OFFSET _STR_CRLF
	*** 000207	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
	*** 00020c	1e 			push	ds
	*** 00020d	68 00 00 		push	OFFSET DGROUP:$SG2658
	*** 000210	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
;|***         return ( (msg == MIDM_GETNUMDEVS) ? 0L : MMSYSERR_NOTENABLED );
; Line 170
					$I2657:
	*** 000215	83 fe 35 		cmp	si,53	;0035H
	*** 000218	75 03 			jne	$JCC536
	*** 00021a	e9 6c 02 		jmp	$L2709
					$JCC536:
	*** 00021d	b8 03 00 		mov	ax,3
	*** 000220	99 			cwd	
	*** 000221	e9 69 02 		jmp	$EX2652
;|***     }
;|*** 
;|***     /* this driver only supports one device */
;|***     if ( id != 0 ) {
; Line 174
					$I2653:
	*** 000224	83 7e 14 00 		cmp	WORD PTR [bp+20],0	;id
	*** 000228	74 21 			je	$I2659
;|***         D1("invalid midi device id");
; Line 175
	*** 00022a	83 3e 00 00 01 		cmp	WORD PTR _wDebugLevel,1
	*** 00022f	72 14 			jb	$I2660
	*** 000231	68 00 00 		push	SEG _STR_CRLF
	*** 000234	68 00 00 		push	OFFSET _STR_CRLF
	*** 000237	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
	*** 00023c	1e 			push	ds
	*** 00023d	68 00 00 		push	OFFSET DGROUP:$SG2661
	*** 000240	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
;|***         return MMSYSERR_BADDEVICEID;
; Line 176
					$I2660:
	*** 000245	b8 02 00 		mov	ax,2
	*** 000248	e9 40 02 		jmp	$L2710
;|***     }
;|*** 
;|***     switch ( msg ) {
; Line 179
					$I2659:
	*** 00024b	8b 46 12 		mov	ax,WORD PTR [bp+18]	;msg
;|***         case MIDM_GETNUMDEVS:
;|***             D1("MIDM_GETNUMDEVS");
;|***             return 1L;
;|*** 
;|***         case MIDM_GETDEVCAPS:
;|***             D1("MIDM_GETDEVCAPS");
;|***             midGetDevCaps((LPBYTE)dwParam1, (WORD)dwParam2);
;|***             return 0L;
;|*** 
;|***         case MIDM_OPEN:
;|***             D1("MIDM_OPEN");
;|*** 
;|***             /* now attempt to 'acquire' the MIDI input hardware */
;|***             if ( midAcquireHardware() ) {
;|***                 D1("MIDI input hardware is unavailable!");
;|***                 return MMSYSERR_ALLOCATED;
;|***             }
;|*** 
;|***             /* allocate my structure containing info about my client (global */
;|***             /* because I only allow one client to access midi input). */
;|***             gMidiInClient.dwCallback = ((LPMIDIOPENDESC)dwParam1)->dwCallback;
;|***             gMidiInClient.dwInstance = ((LPMIDIOPENDESC)dwParam1)->dwInstance;
;|***             gMidiInClient.hMidi      = ((LPMIDIOPENDESC)dwParam1)->hMidi;
;|***             gMidiInClient.dwFlags    = dwParam2;
;|***             
;|***             /* initialize queue stuff */
;|***             gMIMC.dwCurData = 0;
;|***             gMIMC.lpmhQueue = 0;
;|*** 
;|***             /*  NOTE: we must initialize reference time in case someone adds */
;|***             /*  longdata buffers after opening, then resets the midi stream */
;|***             /*  without starting midi input.  Otherwise, midFreeQ would give */
;|***             /*  inconsistent timestamps */
;|***             gMIMC.dwRefTime = timeGetTime();
;|*** 
;|***             /* notify client */
;|***             midiCallback(&gMidiInClient, MIM_OPEN, 0L, 0L);
;|*** 
;|***             return 0L;
;|*** 
;|***         case MIDM_CLOSE:
;|***             D1("MIDM_CLOSE");
;|*** 
;|***             if ( gMIMC.lpmhQueue )
;|***                 return MIDIERR_STILLPLAYING;
;|*** 
;|***             /* just in case they started input without adding buffers */
;|***             midStop();
;|*** 
;|***             /* now 'release' the MIDI input hardware */
;|***             if ( midReleaseHardware() ) {
;|***                 D1("MIDI input hardware could NOT be released!");
;|***             }
;|*** 
;|***             /* notify client */
;|***             midiCallback(&gMidiInClient, MIM_CLOSE, 0L, 0L);
;|*** 
;|***             return 0L;
;|*** 
;|***         case MIDM_ADDBUFFER:
;|***             D1("MIDM_ADDBUFFER");
;|*** 
;|***             /* attempt to add the buffer */
;|***             return midAddBuffer((LPMIDIHDR)dwParam1);
;|*** 
;|***         case MIDM_START:
;|***             D1("MIDM_START");
;|*** 
;|***             /* initialize all the parsing status variables */
;|***             gMIMC.fSysEx = 0;
;|***             gMIMC.bStatus = 0;
;|***             gMIMC.bBytesLeft = 0;
;|***             gMIMC.bBytePos = 0;
;|***             gMIMC.dwShortMsg = 0;
;|***             gMIMC.dwMsgTime = 0;
;|***             gMIMC.dwRefTime = 0;
;|***             gMIMC.dwCurData = 0;
;|*** 
;|***             /* get a new reference time */
;|***             gMIMC.dwRefTime = timeGetTime();
;|*** 
;|***             midStart();
;|***             return 0L;
;|*** 
;|***         case MIDM_STOP:
;|***             D1("MIDM_STOP");
;|***             midStop();
;|***             return 0L;
;|*** 
;|***         case MIDM_RESET:
;|***             D1("MIDM_RESET");
;|*** 
;|***             /* stop if it is started and release all buffers */
;|***             midStop();
;|***             midFreeQ();
;|***             return 0L;
;|*** 
;|***         default:
;|***             return MMSYSERR_NOTSUPPORTED;
;|***     }
; Line 279
	*** 00024e	2d 35 00 		sub	ax,53	;0035H
	*** 000251	3d 09 00 		cmp	ax,9
	*** 000254	77 1c 			ja	$SD2697
	*** 000256	03 c0 			add	ax,ax
	*** 000258	93 			xchg	ax,bx
	*** 000259	2e ff a7 00 00 		jmp	WORD PTR cs:$L2707[bx]
					$L2707:
	*** 00025e	00 00 				DW	$SC2666
	*** 000260	00 00 				DW	$SC2669
	*** 000262	00 00 				DW	$SC2672
	*** 000264	00 00 				DW	$SC2678
	*** 000266	00 00 				DW	$SD2697
	*** 000268	00 00 				DW	$SD2697
	*** 00026a	00 00 				DW	$SC2685
	*** 00026c	00 00 				DW	$SC2688
	*** 00026e	00 00 				DW	$SC2691
	*** 000270	00 00 				DW	$SC2694
;|***         default:
; Line 277
					$SD2697:
;|***             return MMSYSERR_NOTSUPPORTED;
; Line 278
	*** 000272	b8 08 00 		mov	ax,8
	*** 000275	e9 13 02 		jmp	$L2710
;|***         case MIDM_GETNUMDEVS:
; Line 180
					$SC2666:
;|***             D1("MIDM_GETNUMDEVS");
; Line 181
	*** 000278	83 3e 00 00 01 		cmp	WORD PTR _wDebugLevel,1
	*** 00027d	72 14 			jb	$I2667
	*** 00027f	68 00 00 		push	SEG _STR_CRLF
	*** 000282	68 00 00 		push	OFFSET _STR_CRLF
	*** 000285	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
	*** 00028a	1e 			push	ds
	*** 00028b	68 00 00 		push	OFFSET DGROUP:$SG2668
	*** 00028e	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
;|***             return 1L;
; Line 182
					$I2667:
	*** 000293	b8 01 00 		mov	ax,1
	*** 000296	e9 f2 01 		jmp	$L2710
;|*** 
;|***         case MIDM_GETDEVCAPS:
; Line 184
					$SC2669:
;|***             D1("MIDM_GETDEVCAPS");
; Line 185
	*** 000299	83 3e 00 00 01 		cmp	WORD PTR _wDebugLevel,1
	*** 00029e	72 14 			jb	$I2670
	*** 0002a0	68 00 00 		push	SEG _STR_CRLF
	*** 0002a3	68 00 00 		push	OFFSET _STR_CRLF
	*** 0002a6	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
	*** 0002ab	1e 			push	ds
	*** 0002ac	68 00 00 		push	OFFSET DGROUP:$SG2671
	*** 0002af	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
;|***             midGetDevCaps((LPBYTE)dwParam1, (WORD)dwParam2);
; Line 186
					$I2670:
	*** 0002b4	ff 76 0c 		push	WORD PTR [bp+12]
	*** 0002b7	ff 76 0a 		push	WORD PTR [bp+10]	;dwParam1
	*** 0002ba	ff 76 06 		push	WORD PTR [bp+6]	;dwParam2
	*** 0002bd	e8 b8 fe 		call	MIDGETDEVCAPS
	*** 0002c0	e9 c6 01 		jmp	$L2709
;|***             return 0L;
;|*** 
;|***         case MIDM_OPEN:
; Line 189
					$SC2672:
;|***             D1("MIDM_OPEN");
; Line 190
	*** 0002c3	83 3e 00 00 01 		cmp	WORD PTR _wDebugLevel,1
	*** 0002c8	72 14 			jb	$I2673
	*** 0002ca	68 00 00 		push	SEG _STR_CRLF
	*** 0002cd	68 00 00 		push	OFFSET _STR_CRLF
	*** 0002d0	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
	*** 0002d5	1e 			push	ds
	*** 0002d6	68 00 00 		push	OFFSET DGROUP:$SG2674
	*** 0002d9	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
;|*** 
;|***             /* now attempt to 'acquire' the MIDI input hardware */
;|***             if ( midAcquireHardware() ) {
; Line 193
					$I2673:
	*** 0002de	9a 00 00 00 00 		call	FAR PTR MIDACQUIREHARDWARE
	*** 0002e3	0b c0 			or	ax,ax
	*** 0002e5	74 21 			je	$I2675
;|***                 D1("MIDI input hardware is unavailable!");
; Line 194
	*** 0002e7	83 3e 00 00 01 		cmp	WORD PTR _wDebugLevel,1
	*** 0002ec	72 14 			jb	$I2676
	*** 0002ee	68 00 00 		push	SEG _STR_CRLF
	*** 0002f1	68 00 00 		push	OFFSET _STR_CRLF
	*** 0002f4	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
	*** 0002f9	1e 			push	ds
	*** 0002fa	68 00 00 		push	OFFSET DGROUP:$SG2677
	*** 0002fd	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
;|***                 return MMSYSERR_ALLOCATED;
; Line 195
					$I2676:
	*** 000302	b8 04 00 		mov	ax,4
	*** 000305	e9 83 01 		jmp	$L2710
;|***             }
;|*** 
;|***             /* allocate my structure containing info about my client (global */
;|***             /* because I only allow one client to access midi input). */
;|***             gMidiInClient.dwCallback = ((LPMIDIOPENDESC)dwParam1)->dwCallback;
; Line 200
					$I2675:
	*** 000308	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;dwParam1
	*** 00030b	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 00030f	26 8b 57 04 		mov	dx,WORD PTR es:[bx+4]
	*** 000313	a3 00 00 		mov	WORD PTR _gMidiInClient,ax
	*** 000316	89 16 02 00 		mov	WORD PTR _gMidiInClient+2,dx
;|***             gMidiInClient.dwInstance = ((LPMIDIOPENDESC)dwParam1)->dwInstance;
; Line 201
	*** 00031a	26 8b 47 06 		mov	ax,WORD PTR es:[bx+6]
	*** 00031e	26 8b 57 08 		mov	dx,WORD PTR es:[bx+8]
	*** 000322	a3 04 00 		mov	WORD PTR _gMidiInClient+4,ax
	*** 000325	89 16 06 00 		mov	WORD PTR _gMidiInClient+6,dx
;|***             gMidiInClient.hMidi      = ((LPMIDIOPENDESC)dwParam1)->hMidi;
; Line 202
	*** 000329	26 8b 07 		mov	ax,WORD PTR es:[bx]
	*** 00032c	a3 08 00 		mov	WORD PTR _gMidiInClient+8,ax
;|***             gMidiInClient.dwFlags    = dwParam2;
; Line 203
	*** 00032f	8b 46 06 		mov	ax,WORD PTR [bp+6]	;dwParam2
	*** 000332	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 000335	a3 0a 00 		mov	WORD PTR _gMidiInClient+10,ax
	*** 000338	89 16 0c 00 		mov	WORD PTR _gMidiInClient+12,dx
;|***             
;|***             /* initialize queue stuff */
;|***             gMIMC.dwCurData = 0;
; Line 206
	*** 00033c	2b c0 			sub	ax,ax
	*** 00033e	a3 12 00 		mov	WORD PTR _gMIMC+18,ax
	*** 000341	a3 10 00 		mov	WORD PTR _gMIMC+16,ax
;|***             gMIMC.lpmhQueue = 0;
; Line 207
	*** 000344	a3 16 00 		mov	WORD PTR _gMIMC+22,ax
	*** 000347	a3 14 00 		mov	WORD PTR _gMIMC+20,ax
;|*** 
;|***             /*  NOTE: we must initialize reference time in case someone adds */
;|***             /*  longdata buffers after opening, then resets the midi stream */
;|***             /*  without starting midi input.  Otherwise, midFreeQ would give */
;|***             /*  inconsistent timestamps */
;|***             gMIMC.dwRefTime = timeGetTime();
; Line 213
	*** 00034a	9a 00 00 00 00 		call	FAR PTR TIMEGETTIME
	*** 00034f	a3 0c 00 		mov	WORD PTR _gMIMC+12,ax
	*** 000352	89 16 0e 00 		mov	WORD PTR _gMIMC+14,dx
;|*** 
;|***             /* notify client */
;|***             midiCallback(&gMidiInClient, MIM_OPEN, 0L, 0L);
; Line 216
	*** 000356	68 00 00 		push	OFFSET _gMidiInClient
	*** 000359	68 c1 03 		push	961	;03c1H
	*** 00035c	eb 59 			jmp	SHORT $L2715
;|*** 
;|***             return 0L;
;|*** 
;|***         case MIDM_CLOSE:
; Line 220
					$SC2678:
;|***             D1("MIDM_CLOSE");
; Line 221
	*** 00035e	83 3e 00 00 01 		cmp	WORD PTR _wDebugLevel,1
	*** 000363	72 14 			jb	$I2679
	*** 000365	68 00 00 		push	SEG _STR_CRLF
	*** 000368	68 00 00 		push	OFFSET _STR_CRLF
	*** 00036b	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
	*** 000370	1e 			push	ds
	*** 000371	68 00 00 		push	OFFSET DGROUP:$SG2680
	*** 000374	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
;|*** 
;|***             if ( gMIMC.lpmhQueue )
; Line 223
					$I2679:
	*** 000379	a1 16 00 		mov	ax,WORD PTR _gMIMC+22
	*** 00037c	0b 06 14 00 		or	ax,WORD PTR _gMIMC+20
	*** 000380	74 06 			je	$I2681
;|***                 return MIDIERR_STILLPLAYING;
; Line 224
	*** 000382	b8 41 00 		mov	ax,65	;0041H
	*** 000385	e9 03 01 		jmp	$L2710
;|*** 
;|***             /* just in case they started input without adding buffers */
;|***             midStop();
; Line 227
					$I2681:
	*** 000388	9a 00 00 00 00 		call	FAR PTR MIDSTOP
;|*** 
;|***             /* now 'release' the MIDI input hardware */
;|***             if ( midReleaseHardware() ) {
; Line 230
	*** 00038d	9a 00 00 00 00 		call	FAR PTR MIDRELEASEHARDWARE
	*** 000392	0b c0 			or	ax,ax
	*** 000394	74 1b 			je	$I2682
;|***                 D1("MIDI input hardware could NOT be released!");
; Line 231
	*** 000396	83 3e 00 00 01 		cmp	WORD PTR _wDebugLevel,1
	*** 00039b	72 14 			jb	$I2682
	*** 00039d	68 00 00 		push	SEG _STR_CRLF
	*** 0003a0	68 00 00 		push	OFFSET _STR_CRLF
	*** 0003a3	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
	*** 0003a8	1e 			push	ds
	*** 0003a9	68 00 00 		push	OFFSET DGROUP:$SG2684
	*** 0003ac	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
;|***             }
;|*** 
;|***             /* notify client */
;|***             midiCallback(&gMidiInClient, MIM_CLOSE, 0L, 0L);
; Line 235
					$I2682:
	*** 0003b1	68 00 00 		push	OFFSET _gMidiInClient
	*** 0003b4	68 c2 03 		push	962	;03c2H
					$L2715:
	*** 0003b7	6a 00 			push	0
	*** 0003b9	6a 00 			push	0
	*** 0003bb	6a 00 			push	0
	*** 0003bd	6a 00 			push	0
	*** 0003bf	9a 00 00 00 00 		call	FAR PTR MIDICALLBACK
;|*** 
;|***             return 0L;
; Line 237
	*** 0003c4	e9 c2 00 		jmp	$L2709
;|*** 
;|***         case MIDM_ADDBUFFER:
; Line 239
					$SC2685:
;|***             D1("MIDM_ADDBUFFER");
; Line 240
	*** 0003c7	83 3e 00 00 01 		cmp	WORD PTR _wDebugLevel,1
	*** 0003cc	72 14 			jb	$I2686
	*** 0003ce	68 00 00 		push	SEG _STR_CRLF
	*** 0003d1	68 00 00 		push	OFFSET _STR_CRLF
	*** 0003d4	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
	*** 0003d9	1e 			push	ds
	*** 0003da	68 00 00 		push	OFFSET DGROUP:$SG2687
	*** 0003dd	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
;|*** 
;|***             /* attempt to add the buffer */
;|***             return midAddBuffer((LPMIDIHDR)dwParam1);
; Line 243
					$I2686:
	*** 0003e2	ff 76 0c 		push	WORD PTR [bp+12]
	*** 0003e5	ff 76 0a 		push	WORD PTR [bp+10]	;dwParam1
	*** 0003e8	e8 97 fc 		call	MIDADDBUFFER
	*** 0003eb	e9 9f 00 		jmp	$EX2652
;|*** 
;|***         case MIDM_START:
; Line 245
					$SC2688:
;|***             D1("MIDM_START");
; Line 246
	*** 0003ee	83 3e 00 00 01 		cmp	WORD PTR _wDebugLevel,1
	*** 0003f3	72 14 			jb	$I2689
	*** 0003f5	68 00 00 		push	SEG _STR_CRLF
	*** 0003f8	68 00 00 		push	OFFSET _STR_CRLF
	*** 0003fb	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
	*** 000400	1e 			push	ds
	*** 000401	68 00 00 		push	OFFSET DGROUP:$SG2690
	*** 000404	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
;|*** 
;|***             /* initialize all the parsing status variables */
;|***             gMIMC.fSysEx = 0;
; Line 249
					$I2689:
;|***             gMIMC.bStatus = 0;
;|***             gMIMC.bBytesLeft = 0;
;|***             gMIMC.bBytePos = 0;
; Line 252
	*** 000409	32 c0 			xor	al,al
	*** 00040b	a2 00 00 		mov	BYTE PTR _gMIMC,al
	*** 00040e	a2 01 00 		mov	BYTE PTR _gMIMC+1,al
	*** 000411	a2 02 00 		mov	BYTE PTR _gMIMC+2,al
	*** 000414	a2 03 00 		mov	BYTE PTR _gMIMC+3,al
;|***             gMIMC.dwShortMsg = 0;
; Line 253
	*** 000417	2b c0 			sub	ax,ax
	*** 000419	a3 06 00 		mov	WORD PTR _gMIMC+6,ax
	*** 00041c	a3 04 00 		mov	WORD PTR _gMIMC+4,ax
;|***             gMIMC.dwMsgTime = 0;
; Line 254
	*** 00041f	a3 0a 00 		mov	WORD PTR _gMIMC+10,ax
	*** 000422	a3 08 00 		mov	WORD PTR _gMIMC+8,ax
;|***             gMIMC.dwRefTime = 0;
; Line 255
	*** 000425	a3 0e 00 		mov	WORD PTR _gMIMC+14,ax
	*** 000428	a3 0c 00 		mov	WORD PTR _gMIMC+12,ax
;|***             gMIMC.dwCurData = 0;
; Line 256
	*** 00042b	a3 12 00 		mov	WORD PTR _gMIMC+18,ax
	*** 00042e	a3 10 00 		mov	WORD PTR _gMIMC+16,ax
;|*** 
;|***             /* get a new reference time */
;|***             gMIMC.dwRefTime = timeGetTime();
; Line 259
	*** 000431	9a 00 00 00 00 		call	FAR PTR TIMEGETTIME
	*** 000436	a3 0c 00 		mov	WORD PTR _gMIMC+12,ax
	*** 000439	89 16 0e 00 		mov	WORD PTR _gMIMC+14,dx
;|*** 
;|***             midStart();
; Line 261
	*** 00043d	9a 00 00 00 00 		call	FAR PTR MIDSTART
;|***             return 0L;
; Line 262
	*** 000442	eb 45 			jmp	SHORT $L2709
;|*** 
;|***         case MIDM_STOP:
; Line 264
					$SC2691:
;|***             D1("MIDM_STOP");
; Line 265
	*** 000444	83 3e 00 00 01 		cmp	WORD PTR _wDebugLevel,1
	*** 000449	72 14 			jb	$I2692
	*** 00044b	68 00 00 		push	SEG _STR_CRLF
	*** 00044e	68 00 00 		push	OFFSET _STR_CRLF
	*** 000451	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
	*** 000456	1e 			push	ds
	*** 000457	68 00 00 		push	OFFSET DGROUP:$SG2693
	*** 00045a	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
;|***             midStop();
; Line 266
					$I2692:
	*** 00045f	9a 00 00 00 00 		call	FAR PTR MIDSTOP
;|***             return 0L;
; Line 267
	*** 000464	eb 23 			jmp	SHORT $L2709
;|*** 
;|***         case MIDM_RESET:
; Line 269
					$SC2694:
;|***             D1("MIDM_RESET");
; Line 270
	*** 000466	83 3e 00 00 01 		cmp	WORD PTR _wDebugLevel,1
	*** 00046b	72 14 			jb	$I2695
	*** 00046d	68 00 00 		push	SEG _STR_CRLF
	*** 000470	68 00 00 		push	OFFSET _STR_CRLF
	*** 000473	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
	*** 000478	1e 			push	ds
	*** 000479	68 00 00 		push	OFFSET DGROUP:$SG2696
	*** 00047c	9a 00 00 00 00 		call	FAR PTR OUTPUTDEBUGSTR
;|*** 
;|***             /* stop if it is started and release all buffers */
;|***             midStop();
; Line 273
					$I2695:
	*** 000481	9a 00 00 00 00 		call	FAR PTR MIDSTOP
;|***             midFreeQ();
; Line 274
	*** 000486	e8 77 fb 		call	MIDFREEQ
;|***             return 0L;
; Line 275
					$L2709:
	*** 000489	33 c0 			xor	ax,ax
					$L2710:
	*** 00048b	33 d2 			xor	dx,dx
;|*** 
;|***         default:
;|***             return MMSYSERR_NOTSUPPORTED;
;|***     }
;|*** 
;|***     /* should never get here */
;|***     AssertF(0);
;|***     return MMSYSERR_NOTSUPPORTED;
;|*** }
; Line 284
					$EX2652:
	*** 00048d	1f 			pop	ds
	*** 00048e	5e 			pop	si
	*** 00048f	c9 			leave	
	*** 000490	ca 10 00 		ret	16	;00000010H
	*** 000493	90 			nop	

MIDMESSAGE	ENDP
MIDI	ENDS
END
