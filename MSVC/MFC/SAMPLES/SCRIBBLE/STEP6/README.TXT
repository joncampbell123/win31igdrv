========================================================================
	   MICROSOFT FOUNDATION CLASS LIBRARY : SCRIBBLE
========================================================================


This SCRIBBLE/STEP6 subdirectory shows what the SCRIBBLE sources
look like after you have completed STEP6 of the tutorial in the
Microsoft Foundation Classes User's Guide.

You can also look at the sources in this directory rather than
manually follow the tutorial instructions for STEP6.


The following summarizes what each SCRIBBLE STEP illustrates:

STEP=0  This is the unedited version of Scribble as generated by
		App Wizard when you select the following options:
		* Project Name: scribble
		* MDI
		* default Advanced options, except turn off VBX support,
		  and turn on Help support
		* use the Classes... option to do the following:
		  + change the following class names:
				CScribbleDoc  -> CScribDoc
				CScribbleView -> CScribView
		  + for CScribDoc, define the file extension to be "scb"

STEP=1  This is the graphical user interface equivalent of
		the common Hello World sample application.  Instead of
		just displaying "Hello World" in text on the screen, this
		version of the application lets you draw "Hello World!"
		on the screen with the mouse

		In this step of the tutorial, a relatively small amount
		of code is added to support the application-specific
		tasks of capturing mouse scribbling on the screen and
		serializes the drawing to the document.  MFC takes care
		of the rest, including:
		* File New, Open, Save (As)
		* File Print, Print Preview
		* MDI management
		* toolbar and status bar management
		* context-sensitive help for common topics

		The printing will look tiny because this version of
		Scribble is kept simple by working in device-dependent
		MM_TEXT mapping mode.  This problem will be fixed in
		STEP5 through the use of a device-independent mapping
		mode, MM_LOENGLISH.

STEP=2  This step illustrates adding application-specific menu items
		and toolbar buttons using App Studio, binding them to commands,
		and implementing ON_COMMAND handlers and ON_UPDATE_COMMAND_UI
		handlers.

		The illustration consists of two commands:
		* Edit Clear All command, handled by the document.
		* Pen Thick Line command, handled by the document also.  This
		  command is bound to both a menu item and a toolbar button.

STEP=3  This step illustrates Class Wizard-assisted dialog initialization,
		validation, and reply.  Scribble's Pen Width dialog allows the
		end-user to specify the size of the "thick" and "thin" pens.

STEP=4  This step illustrates scrolling and splitting.  Splitting
		introduces multiple views of the Scribble document, and
		therefore introduces the technique of passing "hints"
		to other views via CDocument::UpdateAllViews.

		The "hint" tells the other view that it needs to invalidate
		itself, but not completely-- only the area specified by the
		"hint".  We choose the CStrokeItem object to be the unit of
		"hint".  Of course, to take advantage of this hint, the view's
		OnDraw() function needs a way of determining what area of
		the window maps to the stroke.  We do this by computing
		the bounding rectangle of the stroke just one time, at the time
		it is first created, and store that rect as a permanent
		(serialized) member of the CStrokeItem object.

		Thus, this step introduces "smart repainting" in addition
		to introducing scrolling and splitting.

		This step requires the addition of a CScribFrame class.

STEP=5  This step illustrates printing.  We get "cheap" printing
		as early as STEP1.  In this step we illustrate smarter
		printing by:
		1) changing the mapping mode of the view from MM_TEXT to
		   a device-independent mode (MM_LOENGLISH)
		2) adding support for multiple pages
		3) adding printed page adornments

		We illustrate multiple pages by making the first page a
		title page, which shows the name of the file.  The second
		page is the drawing itself.

		We illustrate page adornments by printing a heading at the
		top of the drawing.  The heading shows the name of the file.
STEP=6  This step illustrates context-sensitive help.  We could have
		used the App Wizard "Support Help" option in Step 1 to generate
		(1) code added to CScribbleApp and (2) .RTF files in a
		SCRIBBLE\HLP subdirectory.  Instead, though, we wait until
		this step to do so.  This gives us an opportunity to illustrate
		how you can run App Wizard a second time to generate additional
		options, and then manually copy code and resources-- following
		a traditional "borrow from sample code" practice.

		In this step, we also run the MAKEHM (Make Help Map) tool
		to generate .HPJ [MAP] entries for application-specific
		commands.

